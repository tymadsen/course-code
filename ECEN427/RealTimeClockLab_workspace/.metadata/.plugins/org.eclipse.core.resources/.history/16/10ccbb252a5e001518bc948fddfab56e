#include "xgpio.h"          // Provides access to PB GPIO driver.
#include <stdio.h>          // xil_printf and so forth.
#include "platform.h"       // Enables caching and other system stuff.
#include "mb_interface.h"   // provides the microblaze interrupt enables, etc.
#include "xintc_l.h"        // Provides handy macros for the interrupt controller.
#define DOWN 0x4
#define LEFT 0x8
#define RIGHT 0x2
#define CENTER 0x1
#define UP 0x10
#define TRUE 1
#define FALSE 0
 
XGpio gpLED;  // This is a handle for the LED GPIO block.
XGpio gpPB;   // This is a handle for the push-button GPIO block.
int currentButtonState, debouncedButtonState;
int fitCounter = 0;
int printCounter = 0;
int btnCounter = 0;
int seconds = 0;
int minutes = 0;
int hours = 0;

// This takes in two button states and evaluates if they are debounced
void debounce_buttons(){
	debouncedButtonState = currentButtonState & 0x0000001F;
}
void inc_dec_hours(int inc){
	if(inc) {
		hours++;
		if(hours == 24){
			hours = 0;
		}
	}
	else {
		hours--;
		if(hours == -1) {
			hours = 23;
		}
	}
}

void inc_dec_mins(int inc){
	if(inc) {
		minutes++;
		if(minutes == 60){
			minutes = 0;
			if(debouncedButtonState == 0){
				inc_dec_hours(TRUE);
			}
		}
	}
	else {
		minutes--;
		if(minutes == -1) {
			minutes = 59;
		}
	}
}

void inc_dec_secs(int inc){
	if(inc) {
		seconds++;
		if(seconds == 60){
			seconds = 0;
			if(debouncedButtonState == 0){
				inc_dec_mins(TRUE);
			}
		}
	}
	else {
		seconds--;
		if(seconds == -1){
			seconds = 59;
		}
	}
}

void inc_clock(){
	//down
	if(debouncedButtonState & DOWN) {
		//left (hours)
		if(debouncedButtonState & LEFT) {
			inc_dec_hours(FALSE);
		}
		//middle (mins)
		if(debouncedButtonState & CENTER) {
			inc_dec_mins(FALSE);
		}
		//right (secs)
		if(debouncedButtonState & RIGHT) {
			inc_dec_secs(FALSE);
		}
	}
	//up
	if(debouncedButtonState & UP) {
		//left (hours)
		if(debouncedButtonState & LEFT) {
			inc_dec_hours(TRUE);
		}
		//middle (mins)
		if(debouncedButtonState & CENTER) {
			inc_dec_mins(TRUE);
		}
		//right (secs)
		if(debouncedButtonState & RIGHT) {
			inc_dec_secs(TRUE);
		}
	}
}
 
// This is invoked in response to a timer interrupt.
// It does 2 things: 1) debounce switches, and 2) advances the time.
void timer_interrupt_handler() {
	fitCounter++;
	printCounter++;
	if(fitCounter >= 100) {
		if(debouncedButtonState == 0){
			inc_dec_secs(TRUE);
		}
		fitCounter = 0;
	}
	if(printCounter >= 20) {
		xil_printf("\r%02d:%02d:%02d", hours, minutes, seconds);
		printCounter = 0;
	}
	if(btnCounter == 7){
		//update time
		debounce_buttons();
		//mask for button 1
		if(debouncedButtonState > 0){
			inc_clock();
		}
	}
//	if(btnCounter == 0) {
//		oldButtonState = currentButtonState;
//	}
	btnCounter++;
}
 
// This is invoked each time there is a change in the button state (result of a push or a bounce).
void pb_interrupt_handler() {
  // Clear the GPIO interrupt.
  XGpio_InterruptGlobalDisable(&gpPB);                // Turn off all PB interrupts for now.
  currentButtonState = XGpio_DiscreteRead(&gpPB, 1);  // Get the current state of the buttons.
  // You need to do something here.
  btnCounter = 0;//print("#");
  //todo:
  //Reset button counter
  //

  XGpio_InterruptClear(&gpPB, 0xFFFFFFFF);            // Ack the PB interrupt.
  XGpio_InterruptGlobalEnable(&gpPB);                 // Re-enable PB interrupts.
}
 
// Main interrupt handler, queries the interrupt controller to see what peripheral
// fired the interrupt and then dispatches the corresponding interrupt handler.
// This routine acks the interrupt at the controller level but the peripheral
// interrupt must be ack'd by the dispatched interrupt handler.
void interrupt_handler_dispatcher(void* ptr) {
	int intc_status = XIntc_GetIntrStatus(XPAR_INTC_0_BASEADDR);
	// Check the FIT interrupt first.
	if (intc_status & XPAR_FIT_TIMER_0_INTERRUPT_MASK){
		XIntc_AckIntr(XPAR_INTC_0_BASEADDR, XPAR_FIT_TIMER_0_INTERRUPT_MASK);
		timer_interrupt_handler();
	}
	// Check the push buttons.
	if (intc_status & XPAR_PUSH_BUTTONS_5BITS_IP2INTC_IRPT_MASK){
		XIntc_AckIntr(XPAR_INTC_0_BASEADDR, XPAR_PUSH_BUTTONS_5BITS_IP2INTC_IRPT_MASK);
		pb_interrupt_handler();
	}
}
 
int main (void) {
    init_platform();
    // Initialize the GPIO peripherals.
    int success;
    //print("hello world\n\r");
    success = XGpio_Initialize(&gpPB, XPAR_PUSH_BUTTONS_5BITS_DEVICE_ID);
    // Set the push button peripheral to be inputs.
    XGpio_SetDataDirection(&gpPB, 1, 0x0000001F);
    // Enable the global GPIO interrupt for push buttons.
    XGpio_InterruptGlobalEnable(&gpPB);
    // Enable all interrupts in the push button peripheral.
    XGpio_InterruptEnable(&gpPB, 0xFFFFFFFF);

    //Enable interrupts from the FIT
//    XTime_FITEnableInterrupt();

    microblaze_register_handler(interrupt_handler_dispatcher, NULL);
    XIntc_EnableIntr(XPAR_INTC_0_BASEADDR,
    		(XPAR_FIT_TIMER_0_INTERRUPT_MASK | XPAR_PUSH_BUTTONS_5BITS_IP2INTC_IRPT_MASK));
    XIntc_MasterEnable(XPAR_INTC_0_BASEADDR);
    microblaze_enable_interrupts();
 
    while(1);  // Program never ends.
 
    cleanup_platform();
 
    return 0;
}
